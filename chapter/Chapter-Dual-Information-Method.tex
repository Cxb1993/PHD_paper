\XeTeXinputencoding "GB2312"
\chapter{双信息保存方法（Dual information preserving method）方法}
界面作为最为常见的物理现象之一，广泛的存在于
力学、化学、生物工程、材料科学和计算机图形学等多个学科领域。
界面的准确模拟对于多相流动、晶体生长、火焰的发展和传播等等很多方面的研究都有重要意义。
\section{不同的界面类型和界面方法}
  界面方法最早可以追溯到1958年的洛斯・阿拉莫斯国家实验室发展的 Particle-In-Cell(PIC)方法\cite{evans1957particle,harlow1957hydrodynamic} 。关于不同的界面方法第一章 \ref{cap:interface} 节中有较详细介绍。本章中，我们将从方程的角度来分析界面问题。

忽略力学模型，界面的运动可以抽象为求解对流方程
\begin{equation} \label{eq:interface_mark}
  \frac{\partial z}{\partial t} +\bm{V} \cdot \nabla z =0
  \end{equation}
  其中$\bm{V}$为速度场，$z$为区分界面两侧物质相关的量。
下面分别对不同的界面类型进行分析。
\subsection{传统界面}
方程 (\ref{eq:interface_mark}) 尽管是最简单的对流方程，然而如果我们关注于界面运动时，想要实时的得到几何面（线）是异常困难的。以一维图 \ref{fig:illu_1dinterface} 为例，如果直接对方程 （\ref{eq:interface_mark}) 进行求解，例如采用差分方法，随着间断被耗散，界面将无法识别。

因此，绝大多数界面方法其实并不直接求解方程  (\ref{eq:interface_mark}) 本身，而是采用一种追踪的视角，图 \ref{fig:illu_1dinterface_method} 给出不同界面方法的一维示意图。其中锋面追踪方法直接追踪界面； MAC方法在界面一侧添加标记点；而VOF方法在每一个网格引入一个体积分数函数，将界面的运动转化为体积分数的变化。只有level set方法求解方程 (\ref{eq:interface_mark})，但是也并不直接求解间断函数$z$本身，而是以到界面距离为函数构造一个新的光滑的level set函数$\phi$，求解
\begin{equation*}
\frac{\partial \phi}{\partial t}+\bm{V}\cdot \nabla \phi=0
\end{equation*}

如图 \ref{fig:illu_1dinterface_method}.d 所示，level set方法将$\phi=0$的位置识别为界面位置。 
\input{chapter/tikz/fig_illu_1dinterface.tex}
\input{chapter/tikz/fig_illu_1dinterface_method.tex}
\input{chapter/tikz/fig_illu_2dinterface.tex}

这些界面方法明显可以分成两类，一类全计算域计算的界面捕捉方法，如VOF和level set方法，另外一类只对部分区域进行Lagrangian追踪的界面追踪方法，如锋面追踪、MAC方法等。两类方法各有优势，全域计算的方法更适合处理光滑的几何形状，并且易于处理由于由于流体压缩性导致的膨胀过程；Lagrangian局部追踪的方法更易于处理锋利夹角、大变形以及界面破碎等问题。由于各有明显的优势和缺点，有学者尝试将两种类型方法结合发展如level set-粒子方法，VOF-粒子方法等方法。

\subsection{多相界面和耗散界面}
除经常研究的两相界面外，在工业、化学、生物等很多领域中存在三相甚至更多相物质之间的相互作用，我们可以将这种问题称为多相界面问题。相比两相界面丰富的研究，多相界面的研究无论在理论还是数值方面都很少\cite{kim2005phase}。耗散界面我们在第一章中做过简单介绍，和多界面类似，耗散界面同样也是较难处理的一类界面问题。

传统界面类方法求解多相界面和耗散界面困难的根本原因是由于这些方法都不是针对某一真实的物理量进行求解，如$\gamma$， $ \rho$，而只是从拓扑角度计算界面的运动。这一问题导致传统界面类方法无法直接求解如图 \ref{fig:illu_1ddiffuse_interface} 所示的多相界面和具有界面厚度$\delta$ 的耗散界面。

\input{chapter/tikz/fig_illu_1ddiffuse_interface.tex}

\section{双信息保存方法基本思想}

首先我们考虑两个问题，
\begin{enumerate}[1, ]
	\item
界面捕捉类方法由于采用全计算域求解，可以更好的处理界面膨胀 （图 \ref{fig:illu_1ddiffuse_interface}.a ）、界面张力等光滑函数问题；界面追踪方法由于采用拉格朗日运动思想可以更好的保持界面形状、计算界面大变形和破裂等问题。我们能否同时具备两方面的优点？
\item 传统界面方法都不是直接求解方程 （\ref{eq:interface_mark}）中的和物理相关的量$z$ ，因此较难处理多相界面和耗散界面。界面方法能否针对$z$直接求解？
\end{enumerate}
\subsection{信息点}
粒子方法是一种最直观的界面方法，具有优良的Lagrangian特性，但是由于它明显的不足，学者们更愿意将它作为一种辅助手段，如用作示踪粒子，或者和其它方法结合，用粒子来修正计算结果，如level set-粒子方法，VOF-粒子方法等。粒子方法最大的问题是粒子的离散性和分布的随意性，难以保证全域的覆盖，这样就无法像网格方法一样准确的得到任意位置的信息。
粒子类界面方法主要包括早期的Particle-In-Cell（PIC）方法和目前仍在使用的Marker-In-Cell（MAC）方法。PIC方法采用携带有质量的真实粒子模拟流体的运动，根据粒子携带的信息可以判断界面位置，然而，由于真实粒子无法人为的生成和抹去，无法保证全计算域每个网格都含有粒子。Marker-and-cell (MAC)方法采用标记粒子，粒子除位置以外不含有其它信息，是完全的虚拟粒子，增加和减少都不会影响流场的物理性质，但是由于它完全不携带信息，只能通过有粒子和没有粒子判断界面，仍然无法做到覆盖计算域。

我们知道网格是对真实流场的离散，这种离散其实是真实流场信息在网格点上的映射，我们可以随时加密网格、减少网格或移动网格，尽管这可能影响计算精度，但是并不会改变所研究问题本质。如图 \ref{fig:illu_1d_mesh_point} 类比于网格点，我们可以引入一套和网格点相似的、携带有对流信息$z$在该空间位置投影的粒子，这种粒子可以根据需要增加、减少和移动。
我们将这种携带有对流信息的Lagrangian粒子称为{\bf{信息点}}。

\input{chapter/tikz/fig_illu_1d_mesh_point.tex}

\subsection{单元信息点}
对于固定网格方法，网格点位置是确定的，我们每个时刻都能得到确定的空间点上的计算值，并可以通过高阶插值运算得到空间任何点的近似值；对于运动网格，如自适应加密网格，我们也可以人为的控制网格加密规律，避免过分畸形的网格分布和网格形状。然而，粒子点的运动完全是由速度场决定的，所以粒子点的分布具有很高的随意性。MAC方法也遇到相同的困难，某单元原本含有粒子，但是随着流场膨胀，单元不再含有粒子，但这并不代表该单元产生了相变。MAC方法的解决策略是在初始计算时，在相应状态的单元内放置多达16个粒子来避免这种错误的发生。但是这样即增加计算和存储，又不能从根本上避免粒子分布随意性这一问题。

对于信息点可以随时生成和抹去这一特点，我们为什么不构造一个限定在单元内的信息点呢？既可以解决粒子分布问题，又有利于单元上对流值和粒子上对流值的传递。我们将这种每个单元内唯一的信息点，称为单元信息点，简称为{\bf{单元点（cell-point）}}。下面我们将简单的从一维介绍单元点的计算过程。

\subsubsection{单元点的运动和位置更新}
由于单元点是和每个单元关联的，所以每个单元点无需特殊编号进行区分，单元点的位置也可以根据在单元内相对坐标给出，如图\ref{fig:illu_cell_point}我们首先将$[i-1/2,i+1/2]$定义为第$i$单元。第$i$单元上的单元点坐标为$X$，为到单元中心距离函数。
\input{chapter/tikz/fig_illu_cell_point.tex}

当粒子开始运动后我们需要每一步确定$i$单元点是否运动出单元，如果运动出单元新的位置，我们需要确定单元点新的位置。假设单元点$i$移动速度为$u_C$，则$\Delta t$时间内运动的新坐标为
\begin{equation}
L=X+\Delta t u_C
\end{equation}
所在单元$M$为
\begin{equation}\label{eq:cell_point_M}
  M=i+\text{floor}(L+0.5)
\end{equation}
其中$\text{floor}$为向上取整函数，由于可能运动到新的单元，相对坐标需要更新
\begin{equation}\label{eq:cell_point_X}
  \hat{X}=L-\text{floor}(L+0.5)
\end{equation}

\subsubsection{单元内单元点的更新}
为了保证每一步计算开始单元内只有一个单元点，我们需要在每一步结束将含有多余单元点的和不含单元点的单元进行处理。

我们首先考虑这样一个问题，对于图 \ref{fig:illu_case} 中所示的情况，$i$单元点上$z=1$，$i+1$单元点上$z=0$，那么界面究竟是图中哪种情况呢？这其实是无法区分的，我们规定采用界面落于$z$值较小的信息点位置，既第二种方式。同样的问题，如果一个单元内有两个甚至多个信息点，如图 \ref{fig:illu_cellpoint_case}  我们遵从相同的规定，首先将$z=1$的点消去，然后选择离消去点最近的$z=0$的点作为单元点。

\input{chapter/tikz/fig_illu_case.tex}
\input{chapter/tikz/fig_illu_cellpoint_choose.tex}

对于没有单元点的单元，我们在单元中心引入新的单元点，单元点上对流信息$z$通过{\bf{回溯生成法}}得到。回溯生成法的做法如下：
\begin{enumerate}[1,]
\item 
  首先假设在$k$时间步，在某一未知位置引入一个新的单元点$P'_i$，该点速度为$u'_C$。
\item
  经过时间$\Delta t$，在$k+1$时间步该单元点正好运动到$i$单元中心 $X=0$。
\item 
  由于我们不知道速度$u'_C$，我们假设$u'_C$为$k+1$时间步$i$单元中心的速度。
  $$u'_C=u^{k+1}(i)$$
\item 
  这样我们通过逆速度，根据公式 (\ref{eq:cell_point_M}) 和 (\ref{eq:cell_point_X}) 可以知道$P'_i$在$k$时间步位置$M$和$X$信息。由于$k$时间步一切都是已知的，因此也就可以确定新生成的信息点的准确信息。
  \end{enumerate}

  \input{chapter/tikz/fig_back_construct.tex}





